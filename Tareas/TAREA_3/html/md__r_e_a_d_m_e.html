<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Tarea 3,IE-0207,Sebastián Bonilla Vega, C01263.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tarea 3,IE-0207,Sebastián Bonilla Vega, C01263.</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
INSTRUCCIONES PARA COMPILAR</h1>
<p>Se deben ejecutar los siguientes comandos:</p><ul>
<li><b>make o make all:</b> para compilar el codigo.</li>
<li><b>make clean:</b> para borrar archivos objeto y borrar todos los ejecutables, recomendado hacer siempre una vez que ya se empezo a probar el programa.</li>
<li>**./mainMatrices.exe:** para ejecutar el programa que corresponde a la parte 1, sobre matrices.</li>
<li>**./mainCorreo.exe:** para ejecutar el programa que corresponde a la parte 2, sobre correos.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Templates:</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
<em><b>1. Definicion de Templates:</b></em> Explique el concepto de templates en C++ y proporcione un ejemplo simple.</h2>
<p>Un "template", se refiere a una funcionalidad del lenguaje que permite la creacion de codigo generico y reutilizable. Es una "plantilla", que se puede usar para crear funciones, clases o estructuras de datos que pueden trabajar con varios tipos de datos, sin tener que especificarlos de antemano. El codigo siguiente, va a crear una funcion que va a intercambiar los valores de dos variables, indepentiente de si son ints, floats o algun otro tipo de dato:</p>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">// Definición de la función de intercambio utilizando un template</div>
<div class="line">template &lt;typename T&gt; //nomenclatura de template</div>
<div class="line">void intercambiar(T &amp;a, T &amp;b) { //funcion</div>
<div class="line">    T temp = a;</div>
<div class="line">    a = b;</div>
<div class="line">    b = temp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // Ejemplo con enteros</div>
<div class="line">    int num1 = 5, num2 = 10;</div>
<div class="line">    std::cout &lt;&lt; &quot;Antes del intercambio: num1 = &quot; &lt;&lt; num1 &lt;&lt; &quot;, num2 = &quot; &lt;&lt; num2 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    intercambiar(num1, num2);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Después del intercambio: num1 = &quot; &lt;&lt; num1 &lt;&lt; &quot;, num2 = &quot; &lt;&lt; num2 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    // Ejemplo con doubles</div>
<div class="line">    double dbl1 = 3.14, dbl2 = 2.71;</div>
<div class="line">    std::cout &lt;&lt; &quot;Antes del intercambio: dbl1 = &quot; &lt;&lt; dbl1 &lt;&lt; &quot;, dbl2 = &quot; &lt;&lt; dbl2 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    intercambiar(dbl1, dbl2);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Después del intercambio: dbl1 = &quot; &lt;&lt; dbl1 &lt;&lt; &quot;, dbl2 = &quot; &lt;&lt; dbl2 &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md4"></a>
<em><b>2. Sobrecarga de Plantillas:</b></em> ¿Como se realiza la sobrecarga de funciones con plantillas en C++?</h2>
<p>Cuando se habla de sobrecagra de plantillas, se refiere a la capacidad de definir varais versiones de una misma plantilla, para asi manejar distintos tipos de parametros y con cantidades diferentes. Esto permite adaptar la funcionalidad de la plantilla. Se realiza:</p>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">// Plantilla para imprimir un solo valor</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">void imprimir(T valor) {</div>
<div class="line">    std::cout &lt;&lt; &quot;Valor: &quot; &lt;&lt; valor &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Sobrecarga de la plantilla para imprimir dos valores</div>
<div class="line">template &lt;typename T, typename U&gt;</div>
<div class="line">void imprimir(T valor1, U valor2) {</div>
<div class="line">    std::cout &lt;&lt; &quot;Valor 1: &quot; &lt;&lt; valor1 &lt;&lt; &quot;, Valor 2: &quot; &lt;&lt; valor2 &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // Ejemplos de uso de las funciones sobrecargadas</div>
<div class="line">    imprimir(42);                    // Utiliza la primera versión de la plantilla</div>
<div class="line">    imprimir(3.14, &quot;Hola&quot;);          // Utiliza la segunda versión de la plantilla</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
<em><b>3. Plantillas de Clases:</b></em> Explique como se pueden utilizar plantillas en la definicion de clases en C++.</h2>
<p>Se puede usar para asi crear clases que puedan trabajar con distintos tipos de datos, sin tener que duplicar el codigo. Es particularmente util cuando se deben crear estructuras de datos flexibles con respecto al tipo de dato que se maneja. Un ejemplo de esto:</p>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">// Definiendo la plantilla</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line">class MiContenedor {</div>
<div class="line">private:</div>
<div class="line">    T dato;</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    // Constructor que toma un valor inicial</div>
<div class="line">    MiContenedor(T valorInicial) : dato(valorInicial) {}</div>
<div class="line"> </div>
<div class="line">    // Función para obtener el dato almacenado</div>
<div class="line">    T obtenerDato() const {</div>
<div class="line">        return dato;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Función para establecer un nuevo dato</div>
<div class="line">    void establecerDato(T nuevoDato) {</div>
<div class="line">        dato = nuevoDato;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // Uso de la plantilla de clase con un tipo de dato específico (int)</div>
<div class="line">    MiContenedor&lt;int&gt; contenedorEntero(42);</div>
<div class="line">    std::cout &lt;&lt; &quot;Dato almacenado en el contenedor de enteros: &quot; &lt;&lt; contenedorEntero.obtenerDato() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    // Uso de la plantilla de clase con otro tipo de dato (double)</div>
<div class="line">    MiContenedor&lt;double&gt; contenedorDouble(3.14);</div>
<div class="line">    std::cout &lt;&lt; &quot;Dato almacenado en el contenedor de doubles: &quot; &lt;&lt; contenedorDouble.obtenerDato() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Excepciones:</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
<em><b>4. Manejo de Excepciones:</b></em> Describa los bloques <b>try</b>, <b>catch</b> y <b>throw</b> y como se utilizan para el manejo de excepciones en C++.</h2>
<p>El bloque <b>try</b> se utiliza para envolver el codigo que puede lanzar una excepcion, dentro de este bloque, se mete el codigo que se debe ejecutar y se espera que sucedan excepciones. Si se produce una excepcion dentro del <b>try</b>, se pasa al bloque <b>catch.</b></p>
<p>El bloque <b>catch</b> recibe las excepciones que envia <b>try</b>, pueden haber varios <b>catch</b>, y cada uno puede tener un tipo de excepcion asociado que captura y maneja.</p>
<p>El bloque <b>throw</b> se utiliza para lanzar una excepcion desde cualquier parte del codigo, se puede lanzar un objeto de cualquier tipo, pero el blqoue <b>catch</b> debe corresponder al tipo de dato para poder atraparlo.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
<em><b>5. Excepciones Estandar:</b></em> Nombre al menos tres excepciones estandar proporcionadas por C++ y proporciona ejemplos de situaciones en las que podrıan ser utiles.</h2>
<ul>
<li><b>std::runtime_error</b><ul>
<li>Se utiliza para erroes que ocurren durante la ejecucion del programa y no se pueden preveer. <div class="fragment"><div class="line">#include &lt;stdexcept&gt; //incluyendo para poder invocar las excepciones</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">void realizarOperacion(int valor) { //funcion para realizar la operacion</div>
<div class="line">    if (valor &lt; 0) {</div>
<div class="line">        throw std::runtime_error(&quot;Error: No se puede realizar la operación con un valor negativo&quot;);//uso de la excepcion </div>
<div class="line">    }</div>
<div class="line">    // Realizar la operación</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    try {</div>
<div class="line">        realizarOperacion(-5);</div>
<div class="line">    } catch (const std::runtime_error&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; &quot;Excepción capturada: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>std::invalid_argument:</b><ul>
<li>Idealmente, se utiliza cuando una funcion recibe un argumento que no es valido en el contexto de la funcion. <div class="fragment"><div class="line">#include &lt;stdexcept&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">void dividir(int numerador, int denominador) {</div>
<div class="line">    if (denominador == 0) {</div>
<div class="line">        throw std::invalid_argument(&quot;Error: Denominador no puede ser cero&quot;); //Es protege la funcion que busca dividir, mediante una excepcion si el numero</div>
<div class="line">                                                                            // ingresado es 0.</div>
<div class="line">    }</div>
<div class="line">    // Realizar la división</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    try {</div>
<div class="line">        dividir(10, 0);</div>
<div class="line">    } catch (const std::invalid_argument&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; &quot;Excepción capturada: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>std::out_of_range:</b><ul>
<li>Se utiliza cuando se intenta acceder a un índice o realizar una operación fuera del rango válido.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">#include &lt;stdexcept&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line"> </div>
<div class="line">int obtenerElementoEnIndice(const std::vector&lt;int&gt;&amp; vec, std::size_t indice) {</div>
<div class="line">    if (indice &gt;= vec.size()) {</div>
<div class="line">        throw std::out_of_range(&quot;Error: Índice fuera del rango del vector&quot;);</div>
<div class="line">    }</div>
<div class="line">    return vec[indice];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; numeros = {1, 2, 3, 4, 5};</div>
<div class="line"> </div>
<div class="line">    try {</div>
<div class="line">        int valor = obtenerElementoEnIndice(numeros, 10);</div>
<div class="line">        std::cout &lt;&lt; &quot;Valor obtenido: &quot; &lt;&lt; valor &lt;&lt; std::endl;</div>
<div class="line">    } catch (const std::out_of_range&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; &quot;Excepción capturada: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
<em><b>6. Politica de Manejo de Excepciones:</b></em> ¿Que es una polıtica de manejo de excepciones y por que es importante considerarla al disenar software?</h2>
<p>Una politica de manejo de excepciones se refiere a las decisiones y enfoques que se piensan y toman por un desarrollador en lo que refiere a manejar las excepciones de un programa. Abarca decisiones sobre dónde y cómo se deben lanzar, capturar, y manejar excepciones en el código. Es importante considerar una política de manejo de excepciones al diseñar software cuando se quiere que el codigo sea mas robusto, claro y facil de mantener. Por otro lado, tambien contribuye a la seguridad del codigo al permitirle al codigo que haqga 'cierres controlados', en caso de que algo salga mal.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
<em><b>7. Noexcept:</b></em> Explica el proposito de la palabra clave noexcept y como se utiliza en C++.</h2>
<p>La palabra clave <b>noexcept</b> se utiliza para indicar que una función no lanza excepciones. El propósito principal es optimizar el rendimiento y permitir que el compilador realice ciertas optimizaciones cuando se sabe que una función no generará excepciones. Un ejemplo de sus uso: </p><div class="fragment"><div class="line">void funcionSinExcepciones() noexcept {</div>
<div class="line">    // Código de la función que no lanza excepciones</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void funcionConExcepciones() {</div>
<div class="line">    throw std::runtime_error(&quot;¡Error!&quot;); // Esta función lanza excepciones</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    try {</div>
<div class="line">        funcionSinExcepciones();</div>
<div class="line">        funcionConExcepciones(); // Esta línea lanzará una excepción</div>
<div class="line">    } catch (const std::exception&amp; e) {</div>
<div class="line">        // Manejo de la excepción</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
STL (Standard Template Library):</h1>
<h2><a class="anchor" id="autotoc_md12"></a>
<em><b>8. Contenedores STL:</b></em> Nombre cinco contenedores diferentes de la STL y explique brevemente en que situaciones serıa apropiado usar cada uno.</h2>
<p>Algunos contenedores proporcionados por STL incluyen:</p><ul>
<li><b>std::vector</b>, el cual almacena elementos en un arreglo contiguo en la memoria. Se utiliza cuando se necesita un contenedor de tamano dinamico que permite almacenar y manipular secuencias de elementos de manera eficiente.</li>
<li><b>std::list</b>, que es una lista doblemente enlazada que permite la insercion y eliminacion eficiente de elementos en cualquier posicion. Se utiliza cuando es necesario realizar inserciones o eliminaciones frecuentes, como por ejemplo, a traves de iteradores.</li>
<li><b>std::map</b>, el cual es un contenedor que almacena pares clave-valor, donde cada clave es unica y ordenada. Se utiliza cuando se busca realizar busquedas eficientes, basadas en clases, y tambien cuando se necesia una estructura de datos que asocie claves con valores.</li>
<li><b>std::unordered_set:</b>, el cual es un conjutno, no ordenado, que almacena elementos unicos sin orden particular. Se puede utilizar cuando se necesita verificar de manera rapida la existencia de un elemento en el conjunto, o cuando el orden de los elementos no es importante.</li>
<li><b>std::queue:</b>, el cual es una cola FIFO (First In, First Out) que permite inserciones al final y eliminaciones al frente. Entonces, se puede utilizar cuando se necestia seguir el principio FIFO.</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
<em><b>9. Iteradores en STL:</b></em> Explique el concepto de iteradores en la STL y como se utilizan para acceder a elementos en contenedores.</h2>
<p>Los iteradores son objetos que proporcionan una forma de recorrer secuencias de elementos en contenedores, actúan como punteros que apuntan a elementos en un contenedor y permiten acceder y manipular esos elementos. Los iteradores mas comunes son:</p>
<ul>
<li><b>Iterador begin y end:</b><ul>
<li><em>begin(container)</em> devuelve el iterador al primer elemento del contenedor.</li>
<li><em>end(container)</em> envia al iterador al final del rango. <div class="fragment"><div class="line">#include &lt;vector&gt;</div>
<div class="line"> </div>
<div class="line">std::vector&lt;int&gt; numeros = {1, 2, 3, 4, 5};</div>
<div class="line">auto itInicio = numeros.begin();  // Iterador al primer elemento</div>
<div class="line">auto itFin = numeros.end();       // Iterador al final (fuera del contenedor)</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Iterador de avance (++):</b><ul>
<li>Le indica al iterador a avanzar al siguiente elemento de la secuencia. <div class="fragment"><div class="line">++itInicio;  // Avanza al siguiente elemento</div>
</div><!-- fragment --> <br  />
</li>
</ul>
</li>
<li><b>Operador de Desreferencia (*):</b><ul>
<li>Permite acceder al valor al que apunta el iterador. <div class="fragment"><div class="line">int primerElemento = *itInicio;  // Accede al valor del primer elemento</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Iterador de Retroceso ( &ndash; ):</b><ul>
<li>Permite al iterador retrocedes al elemento anterior en la secuencia. <div class="fragment"><div class="line">--itFin;  // Retrocede al elemento anterior</div>
</div><!-- fragment --></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
<em><b>10. Algoritmos STL:</b></em> Proporcione ejemplos de al menos tres algoritmos de la STL y describa sus funciones basicas.</h2>
<ul>
<li><b>std::sort:</b><ul>
<li>Ordena los elementos de un rango específico en orden ascendente o descendente, de acuerdo a las necesidades del programa.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">#include &lt;algorithm&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; numeros = {5, 2, 8, 1, 3};</div>
<div class="line"> </div>
<div class="line">    // Ordena el vector en orden ascendente</div>
<div class="line">    std::sort(numeros.begin(), numeros.end());</div>
<div class="line"> </div>
<div class="line">    // Ahora &#39;numeros&#39; contiene: {1, 2, 3, 5, 8}</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>std::find:</b><ul>
<li>Ordena lBusca la primera ocurrencia de un valor específico en un rango y devuelve un iterador al elemento encontrado</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">#include &lt;algorithm&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; numeros = {1, 2, 3, 4, 5};</div>
<div class="line">    int valorBuscado = 3;</div>
<div class="line"> </div>
<div class="line">    auto it = std::find(numeros.begin(), numeros.end(), valorBuscado);</div>
<div class="line"> </div>
<div class="line">    if (it != numeros.end()) {</div>
<div class="line">        // Se encontró el valor</div>
<div class="line">    } else {</div>
<div class="line">        // El valor no fue encontrado</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>std::accumulate:</b><ul>
<li>Calcula la suma (u otra operación binaria) de todos los elementos en un rango.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">#include &lt;numeric&gt;</div>
<div class="line">#include &lt;vector&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    std::vector&lt;int&gt; numeros = {1, 2, 3, 4, 5};</div>
<div class="line"> </div>
<div class="line">    // Calcula la suma de los elementos en el vector</div>
<div class="line">    int suma = std::accumulate(numeros.begin(), numeros.end(), 0);</div>
<div class="line"> </div>
<div class="line">    // Ahora &#39;suma&#39; contiene la suma de los elementos: 15</div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
<em><b>11. Algoritmos Personalizados:</b></em> ¿Como podria utilizar un algoritmo personalizado con la STL?</h2>
<p>La STL tambien proporciona una interfaz flexible que te permite aplicar funciones personalizadas a los elementos de un contenedor.Primeramente, se debe definir la funcion y lo que se quiere que esta haga. Esta funcion puede ser una funcion regular, un objeto o una expresion lambda. Luego, se pueden utilizar algoritmos como <b>std::transform</b> o <b>std::for_each</b></p>
<h1><a class="anchor" id="autotoc_md16"></a>
Expresiones Regulares:</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
<em><b>12. Definicion de Expresiones Regulares:</b></em>. ¿Defina que son las expresiones regulares y proporcione un ejemplo simple.</h2>
<p>Las expresiones regulares son patrones de búsqueda y manipulación de cadenas de texto, ya que se describen conjuntos de cadenas de caracteres y se utilizan para buscar, comparar y manipular texto de manera eficiente.Se construyen mediante una combinación de caracteres literales y caracteres especiales que representan ciertos patrones o clases de caracteres. Un ejemplo seria:</p>
<ul>
<li>^[A-Za-z]+$ </li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
<em><b>13. Caracteres Especiales:</b></em> Enumere al menos tres caracteres especiales comunmente utilizados en expresiones regulares y describa sus funciones.</h2>
<p>Siguiendo el ejemplo anterior:</p>
<ul>
<li>**^:** Indica el inicio de la cadena.</li>
<li><b>[A-Za-z]</b>: Representa 'cualquier letra minuscula o mayuscula'</li>
<li><b>+</b>: Indica que debe haber al menos una letra</li>
<li><b>$</b>: Indica el final de la cadena</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
<em><b>14. Uso de Expresiones Regulares en C++:</b></em> ¿Como se utilizan las expresiones regulares en C++? Proporciona un ejemplo.</h2>
<p>Se pueden utilizar expresiones regulares mediante la biblioteca estándar regex. La STL proporciona una interfaz para trabajar con expresiones regulares a través de las clases <b>std::regex</b> y <b>std::regex_match</b>. A nivel de codigo: </p><div class="fragment"><div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;regex&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    // Expresión regular para buscar números enteros en una cadena</div>
<div class="line">    std::regex patron(&quot;[0-9]+&quot;);</div>
<div class="line"> </div>
<div class="line">    // Cadena de texto a analizar</div>
<div class="line">    std::string texto = &quot;La edad de Juan es 25 y la de Maria es 30.&quot;;</div>
<div class="line"> </div>
<div class="line">    // Objeto de coincidencia</div>
<div class="line">    std::smatch coincidencia;</div>
<div class="line"> </div>
<div class="line">    // Buscar coincidencias en la cadena usando la expresión regular</div>
<div class="line">    if (std::regex_search(texto, coincidencia, patron)) {</div>
<div class="line">        std::cout &lt;&lt; &quot;Coincidencia encontrada: &quot; &lt;&lt; coincidencia[0] &lt;&lt; std::endl;</div>
<div class="line">    } else {</div>
<div class="line">        std::cout &lt;&lt; &quot;No se encontraron coincidencias.&quot; &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md20"></a>
<em><b>15. Validacion de Patrones:</b></em> ¿Por que las expresiones regulares son utiles para la validacion de patrones en cadenas de texto?</h2>
<p>Son útiles para la validación de patrones en cadenas de texto por que permiten mas flexibilidad y generalidad. Por otro lado, permite el manejo de busqueda y extraccion de informacion, aumentando asi la eficiencia y el rendimiento. Ademas, la versatilidad en la definicion de reglas permite definir y anazliar patrones mas complejos. Las expresiones regulares tambien son herramientas estandarizadas, que mantienen la consistencia y los estandares definidos por la industria, ademas de facilitar la mantenibilidad del codigo. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
